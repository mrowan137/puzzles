"""
Q: Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
are all figurate (polygonal) numbers and are generated by the following
formulae:

  Triangle                P3,n=n(n+1)/2           1, 3, 6, 10, 15, ...
  Square                  P4,n=n^2                1, 4, 9, 16, 25, ...
  Pentagonal              P5,n=n(3n−1)/2          1, 5, 12, 22, 35, ...
  Hexagonal               P6,n=n(2n−1)            1, 6, 15, 28, 45, ...
  Heptagonal              P7,n=n(5n−3)/2          1, 7, 18, 34, 55, ...
  Octagonal               P8,n=n(3n−2)            1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
interesting properties.

The set is cyclic, in that the last two digits of each number is the first two
digits of the next number (including the last number with the first).
Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal
(P5,44=2882), is represented by a different number in the set.
This is the only set of 4-digit numbers with this property.
Find the sum of the only ordered set of six cyclic 4-digit numbers for which
each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
octagonal, is represented by a different number in the set.

A: 28684 = sum([1281, 8128, 2882, 8256, 5625, 2512])
"""


class FigurateEncoding:
    def __init__(self):
        # fill tables of figurate numbers
        n = 1  # triangular
        self.triangulars = set()
        while self.triangular(n) < 10000:
            self.triangulars.add(self.triangular(n))
            n += 1

        n = 1  # square
        self.squares = set()
        while self.square(n) < 10000:
            self.squares.add(self.square(n))
            n += 1

        n = 1  # pentagonal
        self.pentagonals = set()
        while self.pentagonal(n) < 10000:
            self.pentagonals.add(self.pentagonal(n))
            n += 1

        n = 1  # hexagonal
        self.hexagonals = set()
        while self.hexagonal(n) < 10000:
            self.hexagonals.add(self.hexagonal(n))
            n += 1

        n = 1  # heptagonal
        self.heptagonals = set()
        while self.heptagonal(n) < 10000:
            self.heptagonals.add(self.heptagonal(n))
            n += 1

        n = 1  # octagon
        self.octagonals = set()
        while self.octagonal(n) < 10000:
            self.octagonals.add(self.octagonal(n))
            n += 1

    def triangular(self, n):
        return n * (n + 1) // 2

    def square(self, n):
        return n * n

    def pentagonal(self, n):
        return n * (3 * n - 1) // 2

    def hexagonal(self, n):
        return n * (2 * n - 1)

    def heptagonal(self, n):
        return n * (5 * n - 3) // 2

    def octagonal(self, n):
        return n * (3 * n - 2)

    def __call__(self, n):
        kind = []
        if n in self.triangulars:
            kind += [0]
        if n in self.squares:
            kind += [1]
        if n in self.pentagonals:
            kind += [2]
        if n in self.hexagonals:
            kind += [3]
        if n in self.heptagonals:
            kind += [4]
        if n in self.octagonals:
            kind += [5]

        return kind


figurate_encoding = FigurateEncoding()


def cyclical_figurate_numbers(sequence, need):
    if len(sequence) == 6:
        return sequence

    for n in range(1000, 10000):
        # next number in sequence must be a needed figurate number
        if any(need[i] for i in figurate_encoding(n)):
            print(
                "need = {}, n = {}, ".format(need, n)
                + "figurate_encoding(n) = {}, ".format(figurate_encoding(n))
                + "sequence = {}".format(sequence)
            )
            for j in [k for k in figurate_encoding(n) if need[k]]:
                need[j] = 0
                # different cylical constraints depending
                # on what we have in the sequence so far
                hopefully_full_cycle = []
                if (
                    len(sequence) == 0
                    or 1 <= len(sequence) <= 4
                    and sequence[-1] % 100 == n // 100
                    or len(sequence) == 5
                    and sequence[-1] % 100 == n // 100
                    and n % 100 == sequence[0] // 100
                ):
                    hopefully_full_cycle = cyclical_figurate_numbers(
                        sequence + [n], need
                    )

                need[j] = 1

                if len(hopefully_full_cycle) == 6:
                    return hopefully_full_cycle

    return []


if __name__ == "__main__":
    cfn = cyclical_figurate_numbers([], [1, 1, 1, 1, 1, 1])
    print(
        "Only ordered set of six cyclical 4-digit numbers where "
        + "all polygonal types represented: {} (sum = {})".format(cfn, sum(cfn))
    )
