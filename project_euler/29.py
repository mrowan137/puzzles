"""
Q: Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

2^2=4, 2^3=8, 2^4=16, 2^5=32
3^2=9, 3^3=27, 3^4=81, 3^5=243
4^2=16, 4^3=64, 4^4=256, 4^5=1024
5^2=25, 5^3=125, 5^4=625, 5^5=3125
If they are then placed in numerical order, with any repeats removed, we get the
following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and
2 ≤ b ≤ 100?

A: 9183
"""

import math


def is_prime(n, memo={}):
    if n in memo:
        return memo[n]

    if n < 2:
        return False

    m = int(math.sqrt(n))
    while m > 1:
        if n % m == 0:
            memo[n] = False
            return False

        m -= 1

    memo[n] = True
    return True


def count_distinct(a_low, a_high, b_low, b_high):
    # encode a^b in prime factorization, add it to a set.
    # how big should the vector of primes be?
    # largest element is a_high, at most.
    primes = []
    for n in range(2, a_high + 1):
        if is_prime(n):
            primes.append(n)

    distinct_terms = set()
    for a in range(a_low, a_high + 1):
        # n = p0^q0 * p1^q1 * ... --> [q0, q1, ... ]
        prime_factorization = [0 for _ in primes]
        for i, p in enumerate(primes):
            while a % p == 0:
                a /= p
                prime_factorization[i] += 1

        for b in range(b_low, b_high + 1):
            distinct_terms.add(
                "".join([str(q * b) + "_" for q in prime_factorization])
            )

    return len(distinct_terms)


if __name__ == "__main__":
    al, ah, bl, bh = 2, 100, 2, 100
    print(
        "Distinct terms of a^b for {} <= a <= {} and {} <= b <= {}: {}".format(
            al, ah, bl, bh, count_distinct(al, ah, bl, bh)
        )
    )
